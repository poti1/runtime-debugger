.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Runtime::Debugger 3"
.TH Runtime::Debugger 3 "2022-11-28" "perl v5.34.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "LOGO"
.IX Header "LOGO"
.Vb 5
\& _\|_\|_\|_              _   _
\&|  _ \e _   _ _ _\|_ | |_(_)_ _\|_ _\|_\|_   _\|_\|_
\&| |_) | | | | \*(Aq_ \e| _\|_| | \*(Aq_ \` _ \e / _ \e
\&|  _ <| |_| | | | | |_| | | | | | |  _\|_/
\&|_| \e_\e\e_\|_,_|_| |_|\e_\|_|_|_| |_| |_|\e_\|_\|_|
\&
\& _\|_\|_\|_       _
\&|  _ \e  _\|_\|_| |_\|_  _   _  _\|_ _  _\|_ _  _\|_\|_ _ _\|_
\&| | | |/ _ \e \*(Aq_ \e| | | |/ _\` |/ _\` |/ _ \e \*(Aq_\|_|
\&| |_| |  _\|_/ |_) | |_| | (_| | (_| |  _\|_/ |
\&|_\|_\|_\|_/ \e_\|_\|_|_._\|_/ \e_\|_,_|\e_\|_, |\e_\|_, |\e_\|_\|_|_|
\&                        |_\|_\|_/ |_\|_\|_/
.Ve
.SH "NAME"
Runtime::Debugger \- Easy to use REPL with existing lexicals support.
.PP
(emphasis on "existing" since I have not yet found this support in others modules).
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Start the debugger:
.PP
.Vb 1
\&    perl \-MRuntime::Debugger \-E \*(Aqeval run\*(Aq
.Ve
.PP
Same, but with some variables to play with:
.PP
.Vb 1
\&    perl \-MRuntime::Debugger \-E \*(Aqmy $str1 = "Func"; our $str2 = "Func2"; my @arr1 = "arr\-1"; our @arr2 = "arr\-2"; my %hash1 = qw(hash 1); our %hash2 = qw(hash 2); my $coderef = sub { "code\-ref: @_" }; {package My; sub Func{"My\-Func"} sub Func2{"My\-Func2"}} my $obj = bless {}, "My"; eval run; say $@\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\*(L"What? Another debugger? What about ... ?\*(R"
.SS "perl5db.pl"
.IX Subsection "perl5db.pl"
The standard perl debugger (\f(CW\*(C`perl5db.pl\*(C'\fR) is a powerful tool.
.PP
Using \f(CW\*(C`per5db.pl\*(C'\fR, one would normally be able to do this:
.PP
.Vb 2
\&    # Insert a breakpoint in your code:
\&    $DB::single = 1;
\&
\&    # Then run the perl debugger to navigate there quickly:
\&    PERLDBOPT=\*(AqNonstop\*(Aq perl \-d my_script
.Ve
.PP
If that works for you, then dont' bother with this module!
(joke. still try it.)
.SS "Devel::REPL"
.IX Subsection "Devel::REPL"
This is a great and extendable module!
.PP
Unfortunately, I did not find a way to get the lexical variables
in a scope. (maybe I missed a plugin?!)
.PP
Example:
.PP
.Vb 10
\& perl \-MDevel::REPL \-E \*(Aq
\&     my  $my_var  = 111;                # I want to access this
\&     our $our_var = 222;                # and this.
\&     my $repl = Devel::REPL\->new;
\&     $repl\->load_plugin($_) for qw(
\&         History
\&         LexEnv
\&         DDS
\&         Colors
\&         Completion
\&         CompletionDriver::INC
\&         CompletionDriver::LexEnv
\&         CompletionDriver::Keywords
\&         CompletionDriver::Methods
\&     );
\&     $repl\->run;
\& \*(Aq
.Ve
.PP
Sample Output:
.PP
.Vb 2
\& $ print $my_var
\& Compile error: Global symbol "$my_var" requires explicit package name ...
\& 
\& $ print $our_var
\& Compile error: Global symbol "$our_var" requires explicit package name ...
.Ve
.SS "Devel::REPL"
.IX Subsection "Devel::REPL"
This module also looked nice, but same issue.
.PP
Example:
.PP
.Vb 4
\&    perl \-MReply \-E \*(Aq
\&        my $var=111;
\&        Reply\->new\->run;
\&    \*(Aq
.Ve
.PP
Sample Output:
.PP
.Vb 6
\& > print $var
\& 1
\& > my $var2 = 222
\& 222
\& > print $var2
\& 1
.Ve
.SS "Dilemma"
.IX Subsection "Dilemma"
I have this scenario:
.PP
.Vb 7
\& \- A perl script gets executed.
\& \- The script calls a support module.
\& \- The module reads a test file.
\& \- The module string evals the string contents of the test file.
\& \- The test takes possibly minutes to run (Selenium).
\& \- The test is failing.
\& \- Not sure what is failing.
.Ve
.PP
Normal workflow would be:
.PP
.Vb 4
\& \- Step 1: Apply a fix.
\& \- Step 2: Run the test.
\& \- Step 3: Wait ... wait ... wait.
\& \- Step 4: Go to step 1 if test still fails.
.Ve
.SS "Solution"
.IX Subsection "Solution"
This module basically inserts a read, evaluate, print loop (\s-1REPL\s0)
wherever you need it.
.PP
.Vb 2
\&    use Runtime::Debugger;
\&    eval run;
.Ve
.SS "Tab Completion"
.IX Subsection "Tab Completion"
This module has rich tab completion support:
.PP
.Vb 5
\& \- Press TAB with no input to view commands and available variables in the current scope.
\& \- Press TAB after an arrow ("\->") to auto append either a "{" or "[" or "(".
\&    This depends on the type of variable before it.
\& \- Press TAB after a hash (or hash object) to list available keys. 
\& \- Press TAB anywhere else to list variables.
.Ve
.SS "History"
.IX Subsection "History"
All commands run in the debugger are saved locally and loaded next time the module is loaded.
.SS "Data::Dumper"
.IX Subsection "Data::Dumper"
You can use \*(L"p\*(R" as a print command which can show a simple or complex data structure.
.SS "Ideas"
.IX Subsection "Ideas"
Not sure how to avoid using eval here while keeping access to the top level lexical scope.
.PP
(Maybe through abuse of PadWalker and modifying input dynamically.)
.PP
Any ideas ? :)
.SS "New Variables"
.IX Subsection "New Variables"
Currently it is not possible to create new lexicals (my) variables.
.PP
I have not yet found a way to run \*(L"eval\*(R" with a higher scope of lexicals.
(perhaps there is another way?)
.PP
You can make global variables though if:
.PP
.Vb 3
\& \- By default ($var=123)
\& \- Using our (our $var=123)
\& \- Given the full path ($My::var = 123)
.Ve
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "run"
.IX Subsection "run"
Runs the \s-1REPL\s0 (dont forget eval!)
.PP
.Vb 1
\& eval run
.Ve
.PP
Sets \f(CW$@\fR to the exit reason like '\s-1INT\s0' (Control-C) or 'q' (Normal exit/quit).
.SS "_match"
.IX Subsection "_match"
Returns the possible matches:
.PP
Input:
.PP
.Vb 4
\& words   => ARRAYREF, # What to look for.
\& partial => STRING,   # Default: ""  \- What you typed so far.
\& prepend => "STRING", # Default: ""  \- prepend to each possiblity.
\& nospace => 0,        # Default: "0" \- will not append a space after a completion.
.Ve
.SS "help"
.IX Subsection "help"
Show help section.
.SS "hist"
.IX Subsection "hist"
Show history of commands.
.PP
By default will show 20 commands:
.PP
.Vb 1
\& hist
.Ve
.PP
Same thing:
.PP
.Vb 1
\& hist 20
.Ve
.PP
Can show more:
.PP
.Vb 1
\& hist 50
.Ve
.SS "p"
.IX Subsection "p"
Data::Dumper::Dump anything.
.PP
.Vb 2
\& p 123
\& p [1, 2, 3]
.Ve
.PP
Can adjust the maxdepth (default is 1) to see with: \*(L"#Number\*(R".
.PP
.Vb 1
\& p { a => [1, 2, 3] } #1
.Ve
.PP
Output:
.PP
.Vb 3
\& {
\&   \*(Aqa\*(Aq => \*(AqARRAY(0x55fd914a3d80)\*(Aq
\& }
.Ve
.PP
Set maxdepth to '0' to show all nested structures.
.SS "attr"
.IX Subsection "attr"
Internal use.
.SS "debug"
.IX Subsection "debug"
Internal use.
.SS "term"
.IX Subsection "term"
Internal use.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Install required library:
.PP
.Vb 1
\& sudo apt install libreadline\-dev
.Ve
.PP
Enable this environmental variable to show debugging information:
.PP
.Vb 1
\& RUNTIME_DEBUGGER_DEBUG=1
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "<https://perldoc.perl.org/perldebug>"
.IX Subsection "<https://perldoc.perl.org/perldebug>"
Why not perl debugger?
.SS "<https://metacpan.org/pod/Devel::REPL>"
.IX Subsection "<https://metacpan.org/pod/Devel::REPL>"
Why not Devel::REPL?
.SS "<https://metacpan.org/pod/Reply>"
.IX Subsection "<https://metacpan.org/pod/Reply>"
Why not Reply?
.SH "AUTHOR"
.IX Header "AUTHOR"
Tim Potapov, \f(CW\*(C`<tim.potapov[AT]gmail.com>\*(C'\fR \s-1XX\s0
.SH "BUGS"
.IX Header "BUGS"
\&\- no new lexicals
.PP
Please report any (other) bugs or feature requests to <https://github.com/poti1/runtime\-debugger/issues>.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Runtime::Debugger
.Ve
.PP
You can also look for information at:
.PP
<https://metacpan.org/pod/Runtime::Debugger>
<https://github.com/poti1/runtime\-debugger>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
This software is Copyright (c) 2022 by Tim Potapov.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
